# chapter 3.

1. #### 주어진 자원

주어진 자원이 한정적이기 때문에 시간과 공간을 고려해야한다.

- 우리가 사용하는 앱들이 빠르게 동작하기를 원한다.

첫 번째 기준 -> 시간

- 최대한 메모리를 적게 쓰는 것이 중요

두 번째 기준 - > 용량(메모리)



2. #### 시간 복잡도

문제를 빨리 해결하는 알고리즘을 원함.

- 판단하는 기준 -> 시간으로는 판단이 불가(외부환경에 영향이 미치기 때문)

- 시간 복잡도(time complexity) : 데이타가 많아질수록 얼마나 증가하는지

- | 인풋 크기 | 알고리즘 a | 알고리즘 b |
  | --------- | ---------- | ---------- |
  | 10개      | 10         | 10         |
  | 20개      | 20         | 40         |
  | 100개     | 100        | 1000       |

  2 번째 알고리즘이 시간 복잡도가 크다.

  1 번이 더 빠른 알고리즘.



3. #### 거듭제곱과 로그

시간복잡도를 계산하기 위한 개념

- 거듭제곱
- ex) 2**3 2의 3승 = 8
- ​      2**0 2의 0승 =2/2=1
- ​      2**-1 2의 -1승 = 1/2



- 로그 : 거듭제곱의 반대 개념
- loga b =x   a의 x 승은 b ---? b를 a로 몇번 나누어야 1이 되는가?
- lg = log2
- log2 8 = 3 -> 2의 3승은 8





4. #### 1부터 n 까지의 합

T= 1 + 2 + 3 + 4+ ...+n

T= n + n-1+n-2 ......  +1

n+1이 n개 ===> 2T=N(N+1)

T= N(N+1)/2 => 1부터 N까지의 합





5. #### 점근 표기 법 

INPUT 크기에 따라 실행시간이 결정된다.

EX) INPUT이 리스트라면 길이는 N

- 알고리즘의 소요시간은 20N+40이 될수도 잇고, 2N^2+8N+157이 될수도 있음
- 이 숫자들은 컴퓨터의 성능과 프로그래밍언어의 환경에 따라서 달라짐.
- 평가 --> 점근 표기법(영향력이 가장 큰 것이 기준)



| 소요시간          | 점근표기법 |
| ----------------- | ---------- |
| 20N +40           | O(N)       |
| 2N^2+8N+157       | O(N^2)     |
| 5N^3 + 100N^2 +75 | O(N^3)     |
| 20LOGN+50         | O(LOGN)    |

N이 엄청나게 크다고 가정

- N이 클 때, 좋은 알고리즘과 나쁜 알고리즘의 시간차이가 나기 때문



6. #### 점근 표기법의 의미



- | n     | O(1) | O(n) | O(n^2) | O(n^3)  |
  | ----- | ---- | ---- | ------ | ------- |
  | 100   | 1    | 1    | 1      | 1       |
  | 200   | 1    | 2    | 4      | 8       |
  | 1000  | 1    | 10   | 100    | 1000    |
  | 10000 | 1    | 100  | 10000  | 1000000 |

  - 각 알고리즘의 시간 소요





- | n     | O(1)20년 | O(n)13년 | O(n^2)5년 | O(n^3)1년 |
  | ----- | -------- | -------- | --------- | --------- |
  | 100   | 10       | 1        | 0.1       | 0.01      |
  | 200   | 10       | 2        | 0.4       | 0.08      |
  | 1000  | 10       | 10       | 10        | 10        |
  | 10000 | 10       | 100      | 1000      | 10000     |

  - 컴퓨터사양이 아무리 좋아도 알고리즘이 별로면 한계가 있다!!



7. #### 탐색 알고리즘 평가하기

|      | 선형 | 이진    |
| ---- | ---- | ------- |
| 최고 | O(1) | O(1)    |
| 최악 | O(n) | O(lg n) |

		- 최악의 경우를 따지는 것이 안전하다.

->선형탐색 = O(n)알고리즘

->이진탐색 = O(lg n)알고리즘

8. #### 공간 복잡도

- 인풋 크기에 비례해서 알고리즘이 사용하는 메모리 공간
- for 문 하나로 리턴하는경우 -> O(n)
- for문 두개로 i와 j의 값을 리턴하는 경우 ->O(N^2)





9. #### 유용한 파이썬 기능 정리

- ![image-20200227021203905](C:\Users\USER\AppData\Roaming\Typora\typora-user-images\image-20200227021203905.png)
- ![image-20200227021234209](C:\Users\USER\AppData\Roaming\Typora\typora-user-images\image-20200227021234209.png)
- ![image-20200227021258404](C:\Users\USER\AppData\Roaming\Typora\typora-user-images\image-20200227021258404.png)









